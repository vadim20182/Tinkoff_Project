# TFS Android Spring 2022

#### Общие требования:

- Данная работа является проверкой всех знаний, полученных на курсе.
- Рекомендуется выбирать средства/подходы/инструменты, о которых говорилось на лекциях/семинарах. Использование других средств не запрещено, однако их следует выбирать исходя из здравого смысла и не злоупотреблять ими(например, если нужно показать диалог, лучше пользоваться средствами, предоставленными Android Sdk/Support Library, а не тащить какую-то библиотеку с навороченными диалогами.)
- Прежде всего оценивается работоспособность (реализация всех функций, описанных в ТЗ) и качество кода (архитектура, читаемость, организация кода) приложения. Далее по приоритету - UI/анимация.
- Поощряется стандартный подход к дизайну: material design. Это сэкономит время т.к. многие компоненты material design реализованы в support библиотеках, а иконки для большинства случаев можно импортировать прямо в AndroidStudio
- Моменты не оговоренные в ТЗ могут быть реализованы по своему усмотрению

#### Особо стоит обратить внимание на:

- **Ресурсы**: все строки, используемые в нескольких местах размеры, цвета, и т.п. должны находиться в ресурсах
- **Дублирование кода** (в том числе и в xml-ках с версткой): оно должно быть сведено к минимуму, если вы копируете кусок кода в другое место - это повод задуматься о выносе в переиспользуемый код. В java/kotlin у вас есть интерфейсы, классы, композиция и декорирование (наследование старайтесь не использовать). А для xml можно использовать include, чтобы переиспользовать уже имеющийся layout.
- **Большие классы**: старайтесь не раздувать класс до 100+ строк кода, их становится сложно читать, и скорее всего в этом случае он делает слишком много вещей (single responsibility и все такое).
- **Комментарии**: вместо многочисленных комментариев, старайтесь разбивать код на классы методы с осмысленным именованием, чаще всего это может заменить комментарий. Это избавит вас от надобности поддерживать комментарии в актуальном состоянии при изменении/рефакторинге кода.
- **Следите за утечками**: можно периодически (например после каждого реализованного экрана) включать leak canary и проходиться по экранам.
